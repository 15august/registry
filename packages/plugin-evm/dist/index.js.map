{"version":3,"sources":["../src/actions/bridge.ts","../src/providers/wallet.ts","../src/templates/index.ts","../src/actions/swap.ts","../src/actions/transfer.ts","../src/types/index.ts","../src/index.ts"],"sourcesContent":["import type { IAgentRuntime, Memory, State } from \"@ai16z/eliza\";\nimport {\n    createConfig,\n    executeRoute,\n    ExtendedChain,\n    getRoutes,\n} from \"@lifi/sdk\";\nimport { WalletProvider } from \"../providers/wallet\";\nimport { bridgeTemplate } from \"../templates\";\nimport type { BridgeParams, Transaction } from \"../types\";\n\nexport { bridgeTemplate };\n\nexport class BridgeAction {\n    private config;\n\n    constructor(private walletProvider: WalletProvider) {\n        this.config = createConfig({\n            integrator: \"eliza\",\n            chains: Object.values(this.walletProvider.chains).map((config) => ({\n                id: config.id,\n                name: config.name,\n                key: config.name.toLowerCase(),\n                chainType: \"EVM\",\n                nativeToken: {\n                    ...config.nativeCurrency,\n                    chainId: config.id,\n                    address: \"0x0000000000000000000000000000000000000000\",\n                    coinKey: config.nativeCurrency.symbol,\n                },\n                metamask: {\n                    chainId: `0x${config.id.toString(16)}`,\n                    chainName: config.name,\n                    nativeCurrency: config.nativeCurrency,\n                    rpcUrls: [config.rpcUrls.default.http[0]],\n                    blockExplorerUrls: [config.blockExplorers.default.url],\n                },\n                diamondAddress: \"0x0000000000000000000000000000000000000000\",\n                coin: config.nativeCurrency.symbol,\n                mainnet: true,\n            })) as ExtendedChain[],\n        });\n    }\n\n    async bridge(params: BridgeParams): Promise<Transaction> {\n        const walletClient = this.walletProvider.getWalletClient(\n            params.fromChain\n        );\n        const [fromAddress] = await walletClient.getAddresses();\n\n        const routes = await getRoutes({\n            fromChainId: this.walletProvider.getChainConfigs(params.fromChain)\n                .id,\n            toChainId: this.walletProvider.getChainConfigs(params.toChain).id,\n            fromTokenAddress: params.fromToken,\n            toTokenAddress: params.toToken,\n            fromAmount: params.amount,\n            fromAddress: fromAddress,\n            toAddress: params.toAddress || fromAddress,\n        });\n\n        if (!routes.routes.length) throw new Error(\"No routes found\");\n\n        const execution = await executeRoute(routes.routes[0], this.config);\n        const process = execution.steps[0]?.execution?.process[0];\n\n        if (!process?.status || process.status === \"FAILED\") {\n            throw new Error(\"Transaction failed\");\n        }\n\n        return {\n            hash: process.txHash as `0x${string}`,\n            from: fromAddress,\n            to: routes.routes[0].steps[0].estimate\n                .approvalAddress as `0x${string}`,\n            value: BigInt(params.amount),\n            chainId: this.walletProvider.getChainConfigs(params.fromChain).id,\n        };\n    }\n}\n\nexport const bridgeAction = {\n    name: \"bridge\",\n    description: \"Bridge tokens between different chains\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any\n    ) => {\n        const privateKey = runtime.getSetting(\n            \"EVM_PRIVATE_KEY\"\n        ) as `0x${string}`;\n        const walletProvider = new WalletProvider(privateKey);\n        const action = new BridgeAction(walletProvider);\n        return action.bridge(options);\n    },\n    template: bridgeTemplate,\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    examples: [\n        [\n            {\n                user: \"user\",\n                content: {\n                    text: \"Bridge 1 ETH from Ethereum to Base\",\n                    action: \"CROSS_CHAIN_TRANSFER\",\n                },\n            },\n        ],\n    ],\n    similes: [\"CROSS_CHAIN_TRANSFER\", \"CHAIN_BRIDGE\", \"MOVE_CROSS_CHAIN\"],\n}; // TODO: add more examples / similies\n","import {\n    createPublicClient,\n    createWalletClient,\n    formatUnits,\n    http,\n} from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport type { IAgentRuntime, Provider, Memory, State } from \"@ai16z/eliza\";\nimport type {\n    Address,\n    WalletClient,\n    PublicClient,\n    Chain,\n    HttpTransport,\n    Account,\n    PrivateKeyAccount,\n} from \"viem\";\nimport * as viemChains from \"viem/chains\";\n\nimport type { SupportedChain } from \"../types\";\n\nexport class WalletProvider {\n    private currentChain: SupportedChain = \"mainnet\";\n    chains: Record<string, Chain> = { mainnet: viemChains.mainnet };\n    account: PrivateKeyAccount;\n\n    constructor(privateKey: `0x${string}`, chains?: Record<string, Chain>) {\n        this.setAccount(privateKey);\n        this.setChains(chains);\n\n        if (chains && Object.keys(chains).length > 0) {\n            this.setCurrentChain(Object.keys(chains)[0] as SupportedChain);\n        }\n    }\n\n    getAddress(): Address {\n        return this.account.address;\n    }\n\n    getCurrentChain(): Chain {\n        return this.chains[this.currentChain];\n    }\n\n    getPublicClient(\n        chainName: SupportedChain\n    ): PublicClient<HttpTransport, Chain, Account | undefined> {\n        const transport = this.createHttpTransport(chainName);\n\n        const publicClient = createPublicClient({\n            chain: this.chains[chainName],\n            transport,\n        });\n        return publicClient;\n    }\n\n    getWalletClient(chainName: SupportedChain): WalletClient {\n        const transport = this.createHttpTransport(chainName);\n\n        const walletClient = createWalletClient({\n            chain: this.chains[chainName],\n            transport,\n            account: this.account,\n        });\n\n        return walletClient;\n    }\n\n    getChainConfigs(chainName: SupportedChain): Chain {\n        const chain = viemChains[chainName];\n\n        if (!chain?.id) {\n            throw new Error(\"Invalid chain name\");\n        }\n\n        return chain;\n    }\n\n    async getWalletBalance(): Promise<string | null> {\n        try {\n            const client = this.getPublicClient(this.currentChain);\n            const balance = await client.getBalance({\n                address: this.account.address,\n            });\n            return formatUnits(balance, 18);\n        } catch (error) {\n            console.error(\"Error getting wallet balance:\", error);\n            return null;\n        }\n    }\n\n    async getWalletBalanceForChain(\n        chainName: SupportedChain\n    ): Promise<string | null> {\n        try {\n            const client = this.getPublicClient(chainName);\n            const balance = await client.getBalance({\n                address: this.account.address,\n            });\n            return formatUnits(balance, 18);\n        } catch (error) {\n            console.error(\"Error getting wallet balance:\", error);\n            return null;\n        }\n    }\n\n    addChain(chain: Record<string, Chain>) {\n        this.setChains(chain);\n    }\n\n    switchChain(chainName: SupportedChain, customRpcUrl?: string) {\n        if (!this.chains[chainName]) {\n            const chain = WalletProvider.genChainFromName(\n                chainName,\n                customRpcUrl\n            );\n            this.addChain({ [chainName]: chain });\n        }\n        this.setCurrentChain(chainName);\n    }\n\n    private setAccount = (pk: `0x${string}`) => {\n        this.account = privateKeyToAccount(pk);\n    };\n\n    private setChains = (chains?: Record<string, Chain>) => {\n        if (!chains) {\n            return;\n        }\n        Object.keys(chains).forEach((chain: string) => {\n            this.chains[chain] = chains[chain];\n        });\n    };\n\n    private setCurrentChain = (chain: SupportedChain) => {\n        this.currentChain = chain;\n    };\n\n    private createHttpTransport = (chainName: SupportedChain) => {\n        const chain = this.chains[chainName];\n\n        if (chain.rpcUrls.custom) {\n            return http(chain.rpcUrls.custom.http[0]);\n        }\n        return http(chain.rpcUrls.default.http[0]);\n    };\n\n    static genChainFromName(\n        chainName: string,\n        customRpcUrl?: string | null\n    ): Chain {\n        const baseChain = viemChains[chainName];\n\n        if (!baseChain?.id) {\n            throw new Error(\"Invalid chain name\");\n        }\n\n        const viemChain: Chain = customRpcUrl\n            ? {\n                  ...baseChain,\n                  rpcUrls: {\n                      ...baseChain.rpcUrls,\n                      custom: {\n                          http: [customRpcUrl],\n                      },\n                  },\n              }\n            : baseChain;\n\n        return viemChain;\n    }\n}\n\nconst genChainsFromRuntime = (\n    runtime: IAgentRuntime\n): Record<string, Chain> => {\n    const chainNames =\n        (runtime.character.settings.chains?.evm as SupportedChain[]) || [];\n    const chains = {};\n\n    chainNames.forEach((chainName) => {\n        const rpcUrl = runtime.getSetting(\n            \"ETHEREUM_PROVIDER_\" + chainName.toUpperCase()\n        );\n        const chain = WalletProvider.genChainFromName(chainName, rpcUrl);\n        chains[chainName] = chain;\n    });\n\n    const mainnet_rpcurl = runtime.getSetting(\"EVM_PROVIDER_URL\");\n    if (mainnet_rpcurl) {\n        const chain = WalletProvider.genChainFromName(\n            \"mainnet\",\n            mainnet_rpcurl\n        );\n        chains[\"mainnet\"] = chain;\n    }\n\n    return chains;\n};\n\nexport const initWalletProvider = (runtime: IAgentRuntime) => {\n    const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\n    if (!privateKey) {\n        throw new Error(\"EVM_PRIVATE_KEY is missing\");\n    }\n\n    const chains = genChainsFromRuntime(runtime);\n\n    return new WalletProvider(privateKey as `0x${string}`, chains);\n};\n\nexport const evmWalletProvider: Provider = {\n    async get(\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State\n    ): Promise<string | null> {\n        try {\n            const walletProvider = initWalletProvider(runtime);\n            const address = walletProvider.getAddress();\n            const balance = await walletProvider.getWalletBalance();\n            const chain = walletProvider.getCurrentChain();\n            return `EVM Wallet Address: ${address}\\nBalance: ${balance} ${chain.nativeCurrency.symbol}\\nChain ID: ${chain.id}, Name: ${chain.name}`;\n        } catch (error) {\n            console.error(\"Error in EVM wallet provider:\", error);\n            return null;\n        }\n    },\n};\n","export const transferTemplate = `Given the recent messages and wallet information below:\n\n{{recentMessages}}\n\n{{walletInfo}}\n\nExtract the following information about the requested transfer:\n- Chain to execute on (like in viem/chains)\n- Amount to transfer (only number without coin symbol)\n- Recipient address\n\nRespond with a JSON markdown block containing only the extracted values:\n\n\\`\\`\\`json\n{\n    \"fromChain\": SUPPORTED_CHAINS,\n    \"amount\": string,\n    \"toAddress\": string\n}\n\\`\\`\\`\n`;\n\nexport const bridgeTemplate = `Given the recent messages and wallet information below:\n\n{{recentMessages}}\n\n{{walletInfo}}\n\nExtract the following information about the requested token bridge:\n- Token symbol or address to bridge\n- Source chain\n- Destination chain\n- Amount to bridge\n- Destination address (if specified)\n\nRespond with a JSON markdown block containing only the extracted values:\n\n\\`\\`\\`json\n{\n    \"token\": string | null,\n    \"fromChain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\n    \"toChain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\n    \"amount\": string | null,\n    \"toAddress\": string | null\n}\n\\`\\`\\`\n`;\n\nexport const swapTemplate = `Given the recent messages and wallet information below:\n\n{{recentMessages}}\n\n{{walletInfo}}\n\nExtract the following information about the requested token swap:\n- Input token symbol or address (the token being sold)\n- Output token symbol or address (the token being bought)\n- Amount to swap\n- Chain to execute on\n\nRespond with a JSON markdown block containing only the extracted values. Use null for any values that cannot be determined:\n\n\\`\\`\\`json\n{\n    \"inputToken\": string | null,\n    \"outputToken\": string | null,\n    \"amount\": string | null,\n    \"chain\": \"ethereum\" | \"base\" | \"sepolia\" | \"bsc\" | \"arbitrum\" | \"avalanche\" | \"polygon\" | \"optimism\" | \"cronos\" | \"gnosis\" | \"fantom\" | \"klaytn\" | \"celo\" | \"moonbeam\" | \"aurora\" | \"harmonyOne\" | \"moonriver\" | \"arbitrumNova\" | \"mantle\" | \"linea\" | \"scroll\" | \"filecoin\" | \"taiko\" | \"zksync\" | \"canto\" | null,\n    \"slippage\": number | null\n}\n\\`\\`\\`\n`;\n","import type { IAgentRuntime, Memory, State } from \"@ai16z/eliza\";\nimport {\n    ChainId,\n    createConfig,\n    executeRoute,\n    ExtendedChain,\n    getRoutes,\n} from \"@lifi/sdk\";\nimport { WalletProvider } from \"../providers/wallet\";\nimport { swapTemplate } from \"../templates\";\nimport type { SwapParams, Transaction } from \"../types\";\n\nexport { swapTemplate };\n\nexport class SwapAction {\n    private config;\n\n    constructor(private walletProvider: WalletProvider) {\n        this.config = createConfig({\n            integrator: \"eliza\",\n            chains: Object.values(this.walletProvider.chains).map((config) => ({\n                id: config.id,\n                name: config.name,\n                key: config.name.toLowerCase(),\n                chainType: \"EVM\" as const,\n                nativeToken: {\n                    ...config.nativeCurrency,\n                    chainId: config.id,\n                    address: \"0x0000000000000000000000000000000000000000\",\n                    coinKey: config.nativeCurrency.symbol,\n                    priceUSD: \"0\",\n                    logoURI: \"\",\n                    symbol: config.nativeCurrency.symbol,\n                    decimals: config.nativeCurrency.decimals,\n                    name: config.nativeCurrency.name,\n                },\n                rpcUrls: {\n                    public: { http: [config.rpcUrls.default.http[0]] },\n                },\n                blockExplorerUrls: [config.blockExplorers.default.url],\n                metamask: {\n                    chainId: `0x${config.id.toString(16)}`,\n                    chainName: config.name,\n                    nativeCurrency: config.nativeCurrency,\n                    rpcUrls: [config.rpcUrls.default.http[0]],\n                    blockExplorerUrls: [config.blockExplorers.default.url],\n                },\n                coin: config.nativeCurrency.symbol,\n                mainnet: true,\n                diamondAddress: \"0x0000000000000000000000000000000000000000\",\n            })) as ExtendedChain[],\n        });\n    }\n\n    async swap(params: SwapParams): Promise<Transaction> {\n        const walletClient = this.walletProvider.getWalletClient(params.chain);\n        const [fromAddress] = await walletClient.getAddresses();\n\n        const routes = await getRoutes({\n            fromChainId: this.walletProvider.getChainConfigs(params.chain).id,\n            toChainId: this.walletProvider.getChainConfigs(params.chain).id,\n            fromTokenAddress: params.fromToken,\n            toTokenAddress: params.toToken,\n            fromAmount: params.amount,\n            fromAddress: fromAddress,\n            options: {\n                slippage: params.slippage || 0.5,\n                order: \"RECOMMENDED\",\n            },\n        });\n\n        if (!routes.routes.length) throw new Error(\"No routes found\");\n\n        const execution = await executeRoute(routes.routes[0], this.config);\n        const process = execution.steps[0]?.execution?.process[0];\n\n        if (!process?.status || process.status === \"FAILED\") {\n            throw new Error(\"Transaction failed\");\n        }\n\n        return {\n            hash: process.txHash as `0x${string}`,\n            from: fromAddress,\n            to: routes.routes[0].steps[0].estimate\n                .approvalAddress as `0x${string}`,\n            value: BigInt(params.amount),\n            data: process.data as `0x${string}`,\n            chainId: this.walletProvider.getChainConfigs(params.chain).id,\n        };\n    }\n}\n\nexport const swapAction = {\n    name: \"swap\",\n    description: \"Swap tokens on the same chain\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback?: any\n    ) => {\n        try {\n            const privateKey = runtime.getSetting(\n                \"EVM_PRIVATE_KEY\"\n            ) as `0x${string}`;\n            const walletProvider = new WalletProvider(privateKey);\n            const action = new SwapAction(walletProvider);\n            return await action.swap(options);\n        } catch (error) {\n            console.error(\"Error in swap handler:\", error.message);\n            if (callback) {\n                callback({ text: `Error: ${error.message}` });\n            }\n            return false;\n        }\n    },\n    template: swapTemplate,\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    examples: [\n        [\n            {\n                user: \"user\",\n                content: {\n                    text: \"Swap 1 ETH for USDC on Base\",\n                    action: \"TOKEN_SWAP\",\n                },\n            },\n        ],\n    ],\n    similes: [\"TOKEN_SWAP\", \"EXCHANGE_TOKENS\", \"TRADE_TOKENS\"],\n}; // TODO: add more examples\n","import { ByteArray, formatEther, parseEther, type Hex } from \"viem\";\nimport {\n    composeContext,\n    generateObjectDEPRECATED,\n    HandlerCallback,\n    ModelClass,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@ai16z/eliza\";\n\nimport { initWalletProvider, WalletProvider } from \"../providers/wallet\";\nimport type { Transaction, TransferParams } from \"../types\";\nimport { transferTemplate } from \"../templates\";\n\nexport { transferTemplate };\nexport class TransferAction {\n    constructor(private walletProvider: WalletProvider) {}\n\n    async transfer(params: TransferParams): Promise<Transaction> {\n        console.log(\n            `Transferring: ${params.amount} tokens to (${params.toAddress} on ${params.fromChain})`\n        );\n\n        const walletClient = this.walletProvider.getWalletClient(\n            params.fromChain\n        );\n\n        try {\n            const hash = await walletClient.sendTransaction({\n                account: walletClient.account,\n                to: params.toAddress,\n                value: parseEther(params.amount),\n                data: params.data as Hex,\n                kzg: {\n                    blobToKzgCommitment: function (blob: ByteArray): ByteArray {\n                        throw new Error(\"Function not implemented.\");\n                    },\n                    computeBlobKzgProof: function (\n                        blob: ByteArray,\n                        commitment: ByteArray\n                    ): ByteArray {\n                        throw new Error(\"Function not implemented.\");\n                    },\n                },\n                chain: undefined,\n            });\n\n            return {\n                hash,\n                from: walletClient.account.address,\n                to: params.toAddress,\n                value: parseEther(params.amount),\n                data: params.data as Hex,\n            };\n        } catch (error) {\n            throw new Error(`Transfer failed: ${error.message}`);\n        }\n    }\n}\n\nconst buildTransferDetails = async (\n    state: State,\n    runtime: IAgentRuntime,\n    wp: WalletProvider\n): Promise<TransferParams> => {\n    const context = composeContext({\n        state,\n        template: transferTemplate,\n    });\n\n    const chains = Object.keys(wp.chains);\n\n    const contextWithChains = context.replace(\n        \"SUPPORTED_CHAINS\",\n        chains.toString()\n    );\n\n    const transferDetails = (await generateObjectDEPRECATED({\n        runtime,\n        context: contextWithChains,\n        modelClass: ModelClass.SMALL,\n    })) as TransferParams;\n\n    const existingChain = wp.chains[transferDetails.fromChain];\n\n    if (!existingChain) {\n        throw new Error(\n            \"The chain \" +\n                transferDetails.fromChain +\n                \" not configured yet. Add the chain or choose one from configured: \" +\n                chains.toString()\n        );\n    }\n\n    return transferDetails;\n};\n\nexport const transferAction = {\n    name: \"transfer\",\n    description: \"Transfer tokens between addresses on the same chain\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        options: any,\n        callback?: HandlerCallback\n    ) => {\n        try {\n            const walletProvider = initWalletProvider(runtime);\n            const action = new TransferAction(walletProvider);\n            const transferDetails = await buildTransferDetails(\n                state,\n                runtime,\n                walletProvider\n            );\n            const tx = await action.transfer(transferDetails);\n\n            if (callback) {\n                callback({\n                    text: `Successfully transferred ${formatEther(tx.value)} tokens to ${tx.to}\\nTransaction hash: ${tx.hash}\\nChain: ${transferDetails.fromChain}`,\n                    content: {\n                        success: true,\n                        hash: tx.hash,\n                        amount: formatEther(tx.value),\n                        recipient: tx.to,\n                        chain: transferDetails.fromChain,\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            console.error(\"Error during token transfer:\", error);\n            if (callback) {\n                callback({\n                    text: `Error transferring tokens: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    template: transferTemplate,\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"EVM_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    examples: [\n        [\n            {\n                user: \"assistant\",\n                content: {\n                    text: \"I'll help you transfer 1 ETH to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\n                    action: \"SEND_TOKENS\",\n                },\n            },\n            {\n                user: \"user\",\n                content: {\n                    text: \"Transfer 1 ETH to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\n                    action: \"SEND_TOKENS\",\n                },\n            },\n        ],\n    ],\n    similes: [\"SEND_TOKENS\", \"TOKEN_TRANSFER\", \"MOVE_TOKENS\"],\n};\n","import type { Token } from \"@lifi/types\";\nimport type {\n    Account,\n    Address,\n    Chain,\n    Hash,\n    HttpTransport,\n    PublicClient,\n    WalletClient,\n} from \"viem\";\nimport * as viemChains from \"viem/chains\";\n\nconst SupportedChainList = Object.keys(viemChains) as Array<keyof typeof viemChains>;\nexport type SupportedChain = (typeof SupportedChainList)[number];\n\n// Transaction types\nexport interface Transaction {\n    hash: Hash;\n    from: Address;\n    to: Address;\n    value: bigint;\n    data?: `0x${string}`;\n    chainId?: number;\n}\n\n// Token types\nexport interface TokenWithBalance {\n    token: Token;\n    balance: bigint;\n    formattedBalance: string;\n    priceUSD: string;\n    valueUSD: string;\n}\n\nexport interface WalletBalance {\n    chain: SupportedChain;\n    address: Address;\n    totalValueUSD: string;\n    tokens: TokenWithBalance[];\n}\n\n// Chain configuration\nexport interface ChainMetadata {\n    chainId: number;\n    name: string;\n    chain: Chain;\n    rpcUrl: string;\n    nativeCurrency: {\n        name: string;\n        symbol: string;\n        decimals: number;\n    };\n    blockExplorerUrl: string;\n}\n\nexport interface ChainConfig {\n    chain: Chain;\n    publicClient: PublicClient<HttpTransport, Chain, Account | undefined>;\n    walletClient?: WalletClient;\n}\n\n// Action parameters\nexport interface TransferParams {\n    fromChain: SupportedChain;\n    toAddress: Address;\n    amount: string;\n    data?: `0x${string}`;\n}\n\nexport interface SwapParams {\n    chain: SupportedChain;\n    fromToken: Address;\n    toToken: Address;\n    amount: string;\n    slippage?: number;\n}\n\nexport interface BridgeParams {\n    fromChain: SupportedChain;\n    toChain: SupportedChain;\n    fromToken: Address;\n    toToken: Address;\n    amount: string;\n    toAddress?: Address;\n}\n\n// Plugin configuration\nexport interface EvmPluginConfig {\n    rpcUrl?: {\n        ethereum?: string;\n        base?: string;\n        sepolia?: string;\n        bsc?: string;\n        arbitrum?: string;\n        avalanche?: string;\n        polygon?: string;\n        optimism?: string;\n        cronos?: string;\n        gnosis?: string;\n        fantom?: string;\n        klaytn?: string;\n        celo?: string;\n        moonbeam?: string;\n        aurora?: string;\n        harmonyOne?: string;\n        moonriver?: string;\n        arbitrumNova?: string;\n        mantle?: string;\n        linea?: string;\n        scroll?: string;\n        filecoin?: string;\n        taiko?: string;\n        zksync?: string;\n        canto?: string;\n    };\n    secrets?: {\n        EVM_PRIVATE_KEY: string;\n    };\n    testMode?: boolean;\n    multicall?: {\n        batchSize?: number;\n        wait?: number;\n    };\n}\n\n// LiFi types\nexport type LiFiStatus = {\n    status: \"PENDING\" | \"DONE\" | \"FAILED\";\n    substatus?: string;\n    error?: Error;\n};\n\nexport type LiFiRoute = {\n    transactionHash: Hash;\n    transactionData: `0x${string}`;\n    toAddress: Address;\n    status: LiFiStatus;\n};\n\n// Provider types\nexport interface TokenData extends Token {\n    symbol: string;\n    decimals: number;\n    address: Address;\n    name: string;\n    logoURI?: string;\n    chainId: number;\n}\n\nexport interface TokenPriceResponse {\n    priceUSD: string;\n    token: TokenData;\n}\n\nexport interface TokenListResponse {\n    tokens: TokenData[];\n}\n\nexport interface ProviderError extends Error {\n    code?: number;\n    data?: unknown;\n}\n","export * from \"./actions/bridge\";\nexport * from \"./actions/swap\";\nexport * from \"./actions/transfer\";\nexport * from \"./providers/wallet\";\nexport * from \"./types\";\n\nimport type { Plugin } from \"@ai16z/eliza\";\nimport { bridgeAction } from \"./actions/bridge\";\nimport { swapAction } from \"./actions/swap\";\nimport { transferAction } from \"./actions/transfer\";\nimport { evmWalletProvider } from \"./providers/wallet\";\n\nexport const evmPlugin: Plugin = {\n    name: \"evm\",\n    description: \"EVM blockchain integration plugin\",\n    providers: [evmWalletProvider],\n    evaluators: [],\n    services: [],\n    actions: [transferAction, bridgeAction, swapAction],\n};\n\nexport default evmPlugin;\n"],"mappings":"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","names":["createConfig","executeRoute","getRoutes","createConfig","getRoutes","executeRoute","viemChains"]}